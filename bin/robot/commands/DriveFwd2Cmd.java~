// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package robot.commands;
import java.util.Vector;

import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import robot.Robot;

/**
 *
 */
public class DriveFwd2Cmd extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private double m_dist;
    private double m_pwr;
    private double m_hdg;
    private double m_Mode;
    private double m_TO;
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    
    String line;

    Timer startTmr = new Timer();
    Timer stallTmr = new Timer();
    Timer stopTmr = new Timer();;
    int driveState, driveProfileFlag, stopFlag;
    double currPwr;
    double tgtYaw;
    double m_RemainTgtDist, m_CurrTgtDist, currDist, currSpeed;
    char m_Zone;
    boolean weHadMotionFlag;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveFwd2Cmd(double dist, double pwr, double hdg, double Mode, double TO) {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        m_dist = dist;
        m_pwr = pwr;
        m_hdg = hdg;
        m_Mode = Mode;
        m_TO = TO;

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	line = " ********** Starting DriveFwd2Cmd ***********";
    	line +=  " Dist=" +String.valueOf(m_dist) + " Pwr=" + String.valueOf(m_pwr);
    	line += " TimeOut=" + String.valueOf(m_TO) + " Hdg=" + m_hdg + " Mode=" + String.valueOf(m_Mode);
    	Robot.drivetrain.setLoggingOn();
    	Robot.logger.appendLog(line);
    	System.out.println("DriveFwdCmd Init");
    	setTimeout(m_TO);

    	Robot.drivetrain.resetEncodersAndStats();
    	if (m_dist < 0) m_dist = m_dist * -1;	// Distance is positive, speed can be neg. ??
    	m_RemainTgtDist = m_dist;
    	weHadMotionFlag = false;						// false=NO motion yet, true=Motion has begun
    	stopFlag = 0;									// Clear stop flag to start
    	driveState = 0;								// We are just starting out will need to accel.
    	startTmr.reset();
    	startTmr.start();    	

    	// Mode 0 = Go Straight to current heading
    	// Mode 1 = Go Straight to provided Yaw heading 
    	//  		Yaw =  +-180degrees (+ turn right of straight) , ( -  turn left of straight)
    	if (m_Mode == 0) {
     		tgtYaw = Robot.drivetrain.getGyroYaw();		// Get current yaw and use that as target
    	} else {
    		tgtYaw = m_hdg;								// Pass through provided target yaw
    	}
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
      	// ---- Look up key data to start ----
    	currDist = Robot.drivetrain.getAverageDist();
    	currSpeed = Robot.drivetrain.getAverageSpeed();
    	m_RemainTgtDist = m_dist - currDist;

    	// ----- State 0 (Initial Stop State) -----
    	if (driveState == 0){
    		// were are just starting, we need to move check timer for motion
    		if(startTmr.get() > 0.2) {
    			// we should be moving now
        		driveState = 1;    			
    		}
    	}

    	// ----- State 1 (Accel State) we are accelerating at begining -----
    	if (driveState == 1){
    		// ----- Check to see if we have are done) -----
    		if (m_RemainTgtDist <= 0){
    			// We have hit our target distance so were done
    			driveState = 5;
    		}
    		
    		// ----- Check to see if we have hit something -----    		
       		if (Math.abs(Robot.drivetrain.getAverageSpeed()) <= 0.5){
    			// we have stopped moving we may have hit something so stop
    			driveState = 6;
    		}
    	}

    	if (driveState < 5){
    		// we are not done so send pwr to drivetrain
        	Robot.drivetrain.driveStraightToHdg(m_pwr, tgtYaw);
        	Robot.drivetrain.putZoneData( 6, m_dist, m_RemainTgtDist, tgtYaw, 0 );	// Log distance to tgt 
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
    	if (isTimedOut()) return true;				// used in all modes

    	if (driveState == 5) {
    		// Cmd has completed its distance
    		line = "DriveFwd2Cmd - Done - has reached its target !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;   		
    		return true;
    	}


    	if (driveState == 6) {
    		// We have stalled/Stopped so exit
    		line = "DriveFwd2Cmd - Has STOPPED (stalled) speed below 0.5 inches per sec. !!";
    		Robot.logger.appendLog(line);
    		System.out.println(line) ;
    		return true; 		// We have stopped so exit
    	}
    	
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
		line = "DriveFwd2Cmd has ended !!";
		Robot.logger.appendLog(line);
		System.out.println(line) ;
    	Robot.drivetrain.stopMtrs();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
}
