// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package robot.subsystems;

import robot.Robot;
import robot.RobotMap;
import robot.commands.*;
import robot.subsystems.Drivetrain.DriveMode;
import robot.subsystems.Drivetrain.DrivePIDStatus;
import robot.utils.Rmath;
import robot.utils.SuperPid;
import robot.utils.SuperPid.PidStatus;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.DigitalInput;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class ArmSubSys extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX armMtrCtlr = RobotMap.armSubSysArmMtrCtlr;
    private final AnalogPotentiometer armPotentiometer = RobotMap.armSubSysarmPotentiometer;
    private final DigitalInput armLwrLmtSw = RobotMap.armSubSysarmLwrLmtSw;
    private final DigitalInput armUpperLmtSw = RobotMap.armSubSysArmUpperLmtSw;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    //------------Constants-------------
    // --- default values ---
    static private final double TOPANGLE = 170;			//Angle when full raise
    static private final double BOTANGLE = 33;			//Angle when fully lowered   
    static private double ANGLERANGE = TOPANGLE -  BOTANGLE;    
    static private final double kTopVoltDefault = 2.85;			//Voltage at top
    static private final double kBotVoltDefault = 4.31;			//Voltage at bottom
    static private double kVoltDiffDefault = kBotVoltDefault - kTopVoltDefault;
    
	static final private boolean KLIMIT_SWITCH_PRESSED = true;
	static final private boolean KLIMIT_SWITCH_NOT_PRESSED = false;
	
	public static final double KRaiseSpeedDefault =  +1.0;		// 
	public static final double KLowerSpeedDefault = -.6;		// was -0.4
	public static final double KHoldSpeedDefault  = +0.22;
	public static double KRaiseSpeed, KLowerSpeed, KHoldSpeed;
	public static final double KRaiseSlowSpeed= 0.4;
	public static final double KLowerSlowSpeed= +0.09;
	public static final double KLimitArmTopPos= 165;
	public static final double KLimitArmBotPos= 36;
	
    static private double kTopVolt, kBotVolt, kVoltDiff;    
    static private double ARM_POT_CONV = kVoltDiffDefault / ANGLERANGE; //Volts/degree
 
    // --------- PID Control Elements ----------------
    
	private static double kTgt_AngleDefault = 0 ;
	private static double kPDefault = 0 ;
	private static double kIDefault = 0 ;
	private static double kDDefault = 0 ;
	private static double kFDefault = 0 ;
	private static double kMaxOutDefault = 0 ;
	private static double kAbs_Tol_Default = 0 ;
	private static double kMoveRtDefault = 0;
	private static double kBBang_UpperDefault = 0 ;
	private static double kBBang_LowerDefault = 0 ; 
	
    static public double K_TGT_ANGLE = 0;			// Arm Target Distance
    static public double KP = 0.049;			// Arm P constant
    static public double KI = 0.0;				// Arm P constant	
    static public double KD = 0.29;				// Arm P constant
    static public double KF = 0.0;				// Arm P constant
    static public double KMAXOUT = 1.0;			// Arm Max Output
    static public double ABS_TOL = 1.0;			// Arm Tolerence for Ending
    static public double KMOVERT = 3.6;			// Arm Move Rate
    static public double KBBANG_UPPER = 0.4;	
    static public double KBBANG_LOWER = 0.01; 
	
	double kTgt_Angle, kP, kI, kD, kF, kMaxOut, kAbs_Tol, kMoveRt, kBBang_Upper, kBBang_Lower; 

	private SuperPid mSuperPid = null ;
	private double mPID_I;
	private double mPID_R;
	private double mPID_O;
    private double mPID_S; 
    
 	public enum ArmPIDMode {NULL, TELE, TOP, BOTTOM, SWITCH, SCALE, START, MOVING, HOLDING, RUNNING,  STOPPED};
    private ArmPIDMode mArmPIDMode = ArmPIDMode.START ;  	// this keeps track of our current drive mode
    
    public enum ArmPIDStatus {INIT, RUNNING, DONE, STOPPED, ATEND };
    private ArmPIDStatus mArmPIDStatus = ArmPIDStatus.INIT;

    // --------- Various Constant and Variables ----------------
 	private double mCurrArmPos = 0;						// to be displayed on smartdash
 	private double mDistRemaining = 0;					// Distance remaining to target position
 	private double mCurrArmPwr = 0;						// to be displayed on smartdash
 	private double mCurrArmVolt = 0 ;					// Voltage of Pot
 	private double mLastPos = 0 ;						// Remember last pos. to reduce redundant log prts
 	private int mPrintFlag = 0;							// log voltages once each time lmt sw is hit

	private String line;

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new armByJoystickCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
    	updateSmartDash();					// Update Arm Position Data and limit switches states
    }

    // -- basic constructor
    public ArmSubSys() {
    	mPID_I = 0;
    	mPID_R = 0;
    	mPID_O = 0;
        mPID_S = 0;
        getArmPrefs();
    }
    
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    // --------------------------------------------
    // --------- Basic Motor Commands -------------
    // --------------------------------------------
    
    //Control Motor Commands
    public void armStopMtr(){
        mCurrArmPwr = 0;
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;   	
    }
    public void armHoldMtr(){
    	if (isLowerLmtSwPressed() == true) {
    		mCurrArmPwr = 0;
    	} else {
    		mCurrArmPwr = KHoldSpeed ;
    	}
    	armMtrCtlr.set(-KHoldSpeed);
	   	updateSmartDash() ;
    }
    public void armMoveMtr(double speed){
    	int dir = 0;
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed()) {
    		mPrintFlag = 0;	// we have moved off the limit switch     		
    	}
    	if (speed > KHoldSpeed)
    		dir = +1;		// were going up
    	else
    		dir = -1;		// were holding or going down
    	
    	if ((dir > 0) && (isUpperLmtSwPressed())) {
			 armHoldMtr();
			 recalibrateVoltages();
			 return;
    	}
    	
    	if ((dir < 0) && (isLowerLmtSwPressed())){
			recalibrateVoltages();    		
    		armStopMtr();
    		return;
    	}
    	
    	// This is for slowing down as we reach the top 
		mCurrArmPwr = speed;
		if ((dir > 0) && (getArmPos()>= KLimitArmTopPos)) mCurrArmPwr= KRaiseSlowSpeed;
		
		//  This is for slowing down as we reach bottom
		if ((dir < 0) && (getArmPos()<= KLimitArmBotPos)) mCurrArmPwr= KLowerSlowSpeed;
		
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;
    }
    
    public void armLower() {
    	mCurrArmPwr = KLowerSpeed;
    	if (isLowerLmtSwPressed()){
			recalibrateVoltages();    		
    		armStopMtr();
    		return;
    	}
		
		//  This is for slowing down as we reach bottom
		if (getArmPos()<= KLimitArmBotPos) 	mCurrArmPwr= KLowerSlowSpeed;
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed())	mPrintFlag = 0;	// we have moved off the limit switch 
		armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;    	
    }
    
    public void armRaise() {
    	mCurrArmPwr = KRaiseSpeed;
    	if (isUpperLmtSwPressed()) {
			 armHoldMtr();
			 recalibrateVoltages();
			 return;
    	}
    	if (isUpperLmtSwNotPressed() && isLowerLmtSwPressed()) mPrintFlag = 0;	// we have moved off the limit switch 

		//This is to slow when we reach top
    	if (getArmPos()>= KLimitArmTopPos) mCurrArmPwr= KRaiseSlowSpeed;
    	armMtrCtlr.set(-mCurrArmPwr);
	   	updateSmartDash() ;    	
    }
   
      
    // -------------------------------------
    // ---------  Get Sensor  Data ---------
    // -------------------------------------
    public boolean isUpperLmtSwPressed() {
 	   if (armUpperLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isUpperLmtSwNotPressed() {
 	   if (armUpperLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwPressed() {
 	   if (armLwrLmtSw.get() == KLIMIT_SWITCH_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
    
    public boolean isLowerLmtSwNotPressed() {
 	   if (armLwrLmtSw.get() == KLIMIT_SWITCH_NOT_PRESSED)
 		   return true;
 	   else
 		   return false;
    }
     
    public double getPot(){
    	mCurrArmVolt = armPotentiometer.get() ;
   	 	return mCurrArmVolt;
   } 
    public double getArmPos(){
    	double currPot =  getPot();
    	mCurrArmPos = (( kBotVolt - currPot) / ARM_POT_CONV) + BOTANGLE;
    	mCurrArmPos = Rmath.mRound(mCurrArmPos , 1);		// Round to 1 decimal digits
    	return mCurrArmPos;
    }
    
    public void recalibrateVoltages(){
    	// Self calibration method. Each time we hit the limit switch re-calibrate voltages
    	if 		(isUpperLmtSwPressed() ) {
    		kTopVolt = getPot();
    		line = "Arm Upper Limit Switch hit - ";
    	}
    	else if (isLowerLmtSwPressed() ) {
    		kBotVolt = getPot() ;
    		line = "Arm Lower Limit Switch hit - ";
    	}
		kVoltDiff = kBotVolt - kTopVolt;
    	ARM_POT_CONV = kVoltDiff / ANGLERANGE; //Volts/degree
    	double pos = getArmPos();
    	if (mPrintFlag == 0) {
    		mPrintFlag = 1; 		// lets not immediately reprint values
    		kVoltDiff = kBotVolt - kTopVolt;
    		line += (" kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt +
                     " VOLT DIFF =" + kVoltDiff + " ArmPos=" + pos);
    		Robot.logger.appendLog(line);
    		System.out.println(line);
    	}
    }
    
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -----------------------
    public void getArmPrefs() {
        // grab the relevant coefficients from preferences
    	kTgt_Angle =	Robot.prefs.getDouble("Arm_10_PID_Tgt", kTgt_AngleDefault) ;
    	kP	= 	Robot.prefs.getDouble		("Arm_20_PID_P", kPDefault) ;
    	kI	= 	Robot.prefs.getDouble		("Arm_21_PID_I", kIDefault) ;
    	kD = 	Robot.prefs.getDouble		("Arm_22_PID_D", kDDefault) ;
    	kF = 	Robot.prefs.getDouble		("Arm_23_PID_F", kFDefault) ;
    	
    	kAbs_Tol = Robot.prefs.getDouble	("Arm_30_PID_Tol_In", kAbs_Tol_Default);    	
    	kMoveRt = Robot.prefs.getDouble		("Arm_31_PID_MoveRt",kMoveRtDefault);        
    	kBBang_Lower = Robot.prefs.getDouble("Arm_32_BB_Lwr",kBBang_LowerDefault);
    	kBBang_Upper = Robot.prefs.getDouble("Arm_33_PID_BB_Upr",kBBang_UpperDefault);
    	kMaxOut = Robot.prefs.getDouble		("Arm_34_PID_MaxOut", kMaxOutDefault);  
    	
    	kTopVolt = Robot.prefs.getDouble	("Arm_40_Volt_Upper", kTopVoltDefault) ;
    	kBotVolt = Robot.prefs.getDouble	("Arm_41_Volt_Lower", kBotVoltDefault) ;

    	// Init Potentiometer voltage points upon startup
    	kTopVolt =  kTopVoltDefault ;			// These default values varied between robots so no good
    	kBotVolt =  kBotVoltDefault ;
    	kVoltDiff = kVoltDiffDefault;
    	if (isUpperLmtSwPressed()) {
    		kTopVolt =  getPot() ;					// Robot Arm starts at Top so calibrate at this time
    	} else if (isLowerLmtSwPressed()) {
    		kBotVolt =  getPot() ;					// Robot Arm starts at Top so calibrate at this time	
    	}
    	kVoltDiff =  kBotVolt - kTopVolt;	    	
		ARM_POT_CONV = kVoltDiff / ANGLERANGE; //Volts per inch	
    	mLastPos = getArmPos();
    	line = (" Arm Init kTopVolt=" + kTopVolt + " kBotVolt=" + kBotVolt + 
                " ANGLERANGE=" + ANGLERANGE + " ArmPos=" + mLastPos);
    	Robot.logger.appendLog(line);
    	System.out.println(line);
    	
    	KRaiseSpeed  = Robot.prefs.getDouble	("Arm_50_Raise_Pwr", KRaiseSpeedDefault) ;
    	KLowerSpeed = Robot.prefs.getDouble		("Arm_51_Lower_Pwr", KLowerSpeedDefault) ;
    	KHoldSpeed = Robot.prefs.getDouble		("Arm_52_Hold_Pwr", KHoldSpeedDefault) ;
    	KRaiseSpeed = KRaiseSpeedDefault ;
    	KLowerSpeed = KLowerSpeedDefault ;
    	KHoldSpeed = KHoldSpeedDefault;   	
    }

   // ***********************************************************************
   // 							PID Routines
   // ***********************************************************************

   // a Command can call this to drive elevator to position (Inches)
   public void driveArmByPID(double position) {
	   mArmPIDMode = ArmPIDMode.MOVING;						// record that we're in PID mode
	   getArmPrefs();										// Get all Constants from preferences
	   kTgt_Angle = position;								// overwrite smartdashboard position
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new ArmPid(kTgt_Angle, kP, kI, kD, kF);	// create PID / default values
       Robot.logger.appendLog("**** ARM Pid Stopping *** ");
       logStartData();       
       mSuperPid.start();       							// start the PID IO (and the PID)
 	}

   // a Command can call this to drive elevator to position (Inches)
   public void driveArmByPIDTest() {
	   System.out.println("Entering driveArmByPIDTest");
	   mArmPIDMode = ArmPIDMode.MOVING;						// record that we're in PID mode
	   getArmPrefs();										// Get all Constants from preferences
	   stopPID();											// In case previous Pid still in operation
       mSuperPid = new ArmPid(kTgt_Angle, kP, kI, kD, kF);	// create PID / default values
       Robot.logger.appendLog("**** ARM Pid Stopping *** ");
       logStartData();
	   mSuperPid.start();       							// start the PID IO (and the PID)
 	}
   
   // a Command can call this to see if we're done
   public ArmPIDMode getArmPIDMode() {   
	   return mArmPIDMode ;   
   }
    
   // a Command can call this to force a stop (e.g., from a watchdog timer)    
	public void stopPID() {
		// stop the drive motors and shutdown automation
		//System.out.println("****** STOPPING AUTOMATION *****") ;
	    Robot.logger.appendLog("**** ARM Pid Stopping *** ");
		if (mSuperPid !=null) {
			mSuperPid.stop();
			// Don't delete superPid object because it can leave PID controller unreachable to disable !!!		
		 	//mSuperPid  = null ;			
		}
		mArmPIDMode = ArmPIDMode.TELE ;
		armStopMtr();
	}
   
	// --------------------------------------------------------------------------------
	// Input and Output for Elevator PID controller
	// --------------------------------------------------------------------------------
	private class ArmPid extends SuperPid 
	{
       // constructor - Set Options for SuperPid here !!!
       public ArmPid(double kDIST, double KP, double KI, double KD, double KF) {
           super(kDIST, KP, KI, KD, KF);
           mOptions.setTolerance(kAbs_Tol);								// Set Tolerance
           mOptions.setKeepRunningCriteria(false, kAbs_Tol) ;			// Set to stop at setpoint
           mOptions.setRamping(false, 0);							// Do Not use ramping
       }

       @Override
       public void applyPidOutput(double output) {
    	   mCurrArmPwr = output;
    	   armMoveMtr(output);
           logData();
       }

       @Override
       public double getPidInput() {
           // these are in inches
           return getArmPos();
       }
       
       @Override
       public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut,  double setpoint) {
           if (status == PidStatus.RUNNING) {
               mArmPIDStatus = ArmPIDStatus.RUNNING;
               mPID_I = input ;
               mPID_R = rawOutput ;
               mPID_O = pidOut ;
               mPID_S = setpoint ;
           } else if (status == PidStatus.STOPPED) {
               mArmPIDStatus = ArmPIDStatus.STOPPED;
               armStopMtr();	// The pid never sends a stop .. so motor continues running
               return;
           } else if (status == PidStatus.ATEND) {
               mArmPIDStatus = ArmPIDStatus.ATEND;            	
               return;
           }
       }
	}

	
    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -------------------


	// ------------------- SmartDash board Methods ------------------------------------------
	public void updateSmartDash() {
     	if( isLowerLmtSwPressed())
        	SmartDashboard.putString("Arm LowerLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("Arm LowerLmtSw", "NOT Pressed") ;
     	
     	if( isUpperLmtSwPressed())
        	SmartDashboard.putString("Arm UpperLmtSw", "Pressed") ;
     	else
     		SmartDashboard.putString("Arm UpperLmtSw", "NOT Pressed") ;
     	
     	SmartDashboard.putNumber("Arm CurrPos", Rmath.mRound(getArmPos() , 2)) ;
     	SmartDashboard.putNumber("Arm CurrVolt", getPot()) ;     	
     	SmartDashboard.putNumber("Arm CurrPwr", mCurrArmPwr) ;
	}
	
	public void logData() {
		line =  "Debug - ARM PID,";
    	line += " Tgt=," + kTgt_Angle;
    	line += " , Remaing Dist=," + (kTgt_Angle - mCurrArmPos);
    	line += " , CurrPos=," + Rmath.mRound(mCurrArmPos,2);
    	line += " , CurrVolt=," + mCurrArmVolt;    	
    	line += " , PidOut=," + mCurrArmPwr;    	
    	line += " , LmtSw UL=,";
    	if (isUpperLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	if (isLowerLmtSwPressed())
    		line += "T";
    	else
    		line += "F";
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}
	
	public void logStartData() {
		line =  "Debug - ARM PID STARTING,";
    	line += " Tgt=," + kTgt_Angle;		
    	line += " P=," + kP;
    	line += " I=," + kI;
    	line += " D=," + kD;
    	line += " F=," + kF;
    	// ---- send line to Logger ---------
    	Robot.logger.appendLog(line);
	}	
    
}

