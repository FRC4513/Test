// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package robot.subsystems;

import robot.Robot;
import robot.RobotMap;
import robot.commands.*;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;
import robot.utils.*;

public class Drivetrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX leftFrontMtr = RobotMap.drivetrainLeftFrontMtr;
    private final WPI_TalonSRX rightFrontMtr = RobotMap.drivetrainRightFrontMtr;
    private final DifferentialDrive robotDrive = RobotMap.drivetrainRobotDrive;
    private final AnalogInput sonar = RobotMap.drivetrainSonar;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private AHRS mAHRS = new AHRS(SPI.Port.kMXP);
    //public PowerDistributionPanel pdp = new PowerDistributionPanel();

    // --------- PID Control Elements ----------------
    public enum DriveMode { INIT, TELE, AUTO_ROTATE, AUTO_STRAIGHT, AUTO_PATH, DONE, ATEND };
    private DriveMode mDriveMode = DriveMode.INIT;	// this keeps track of our current drive mode
    
    public enum DrivePIDStatus {INIT, RUNNING, DONE, STOPPED, ATEND };
    private DrivePIDStatus mDrivePIDStatus = DrivePIDStatus.INIT;
    
    private SuperPid mSuperPid = null;				// PID Controller
    
    static public double TGT_STRAIGHT = 0;			// Target Distance
    static public double TGT_STRAIGHT_HDG = 0;		// Target HDG    
    static public double KP_STRAIGHT = 0.076;		// Drive Distance P constant
    static public double KI_STRAIGHT = 0.0;			// Drive Distance I constant	
    static public double KD_STRAIGHT = 0.36;		// Drive Distance D constant
    static public double KF_STRAIGHT = 0.0;			// Drive Distance F constant
    static public double KMAXOUT_STRAIGHT = 1.0;	// Drive Distance F constant
    static public double ABS_TOL_IN = 1.0;
    static public double KDRIFT_STRAIGHT = 0.015;			// Drive Straight P constant
    static public double KMOVERT_STRAIGHT = 3.6;	// Drive Straight MoveRt
    static public double KBBANG_UPPER_STRAIGHT = 0.4;
    static public double KBBANG_LOWER_STRAIGHT = 0.01; 
    

    static public double TGT_ROT = 0;				// Rotation Tgt Angle
    static public double KP_ROT = 0.048;			// Point Turn P constant
    static public double KI_ROT = 0.000;			// Point Turn I constant	
    static private double KD_ROT = 0.14;			// Point Turn D constant
    static public double KF_ROT = 0.000;			// Point Turn F constant
    static public double ROT_MAX_PWR = 0.75;			// PID Min Max Output
    static public double ROT_MOVE_RATE =  3.0;		// PID Setpoint Rate
    static public double ROT_BBANG_UPPER_THRESH = 0.5;
    static public double ROT_BBANG_LOWER_THRESH = 0.1;
    static public double ABS_TOL_DEG = 1.0;
    
    private double mPID_R, mPID_I, mPID_O, mPID_S; 	// Logging data for PID Input, RawOut, Output, Setpoint

    // encoder constants from the part specifications (note they are different leftStats and rightStats)
    static final private double WHEEL_RADIUS_IN = 2.0;
    static final private double LEFT_ENCODER_PPR = 360;  	// 1440 ;  
    static final private double RIGHT_ENCODER_PPR = 250; 	// 1000 ; 
    static final private double LEFT_ENCODER_IN_PER_PULSE = 2.0 * Math.PI * WHEEL_RADIUS_IN / LEFT_ENCODER_PPR;
    static final private double RIGHT_ENCODER_IN_PER_PULSE = 0.05084746;// might work better than the calc'd?

    static final private double DRIVETRAIN_RADIUS_IN = 13; // robot leftStats/right wheel distance from center
    static final private double WHEELBASE = 23.75;			// Distance between wheels

    // --------- User defined Elements ---------------- 
    private double k_EncConvConst = 0.00462016;					// Talon Magnetic Encoder Conv inches/cnt
    
    //private double k_LeftEncConvConst =  0.033998;
    //private double k_RightEncConvConst = 0.050035;
    public static final double kEncoderConvPtTurn = 0.02978;	// avg degrees rotation per encoder cnt.
    //private static final double kMaxSonarConv = 22.0;			// Constant for Inches per volt value
    private String line;

    // These gyro correction values may need to be tweaked based on floor type,
    private static double GYROCORRCNST = 0.400;   // 0.155 maybe lower than ideal??
    private static double GYROCORRLIMIT = 0.800;

    private double gyroCorrection, gyroCorrectedLeft, gyroCorrectedRight;
    double tgtHdg, lastTgtHdg;

    // ---------------------- Drive Statistics ------------------
    private double motorMode;
	private String[] motorModeDesc = {"Coasting", "DriveByJoystick", "Arcade", "Straight", "TankDrive", "PID Fwd", "PID Rotate"  , "Other"};
    private double m_Zone;
    private String[] zoneDesc = {"Coasting", "FwdCmd", "PtTurn", "PID Fwd", "PID Rot", "Joystick","Fwd2Cmd","ArcTurn", "Other"};	
  
    private double mTgtDist, mTgtYaw, mTgtDistRemain, mTgtYawRemain ;
    private double mCurrDist,mCurrYaw ;

    private double motorLeftPwr, motorRightPwr, motorPwr, motorAngle ;
    
    private double PIDTgtDist, PIDTgtDistRemain, PIDTgtYaw, PIDTgtYawRemain;
    
    private DriveStats leftStats = new DriveStats();
    private DriveStats rightStats = new DriveStats();
    private DriveStats avgStats = new DriveStats();

    private boolean m_LogFlag, mLogCalcFlag, mLogCoastFlag;
    private double mLastYaw = 0;			// Used to calculate gyro rot rate
    private double mGyroAngleRate = 0;
    private double mGyroAngleRate2 = 0;
        
    // ------ Position Variables -----
    private double		mLeftDist, mRightDist ;
    private double		mWheelBase = WHEELBASE;
    private Posn		mPosn ;
    private Posn		mPosn2;


    // ---------------------------------------------------------------
    // --- variables to calculate speed and acceleration from encoders
    private double lastTime;

    //********************** Methods **********************************
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    //*****************************************************************
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveByJoystickCmd());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }

    // -- Drivetrain Constructor --
    public Drivetrain() {
        mPosn = new Posn() ;
        mPosn2 = new Posn() ;
        initVar(); 								// Initialize variables to zero
        initEncoders();
        resetEncodersAndStats();
        mTgtYaw = mAHRS.getYaw();
        //rbt = new Rbt(0,0,0);					// Clear robot position Date
        robotDrive.setSafetyEnabled(false);		// possibly remove this line may not be needed
        // set the Inches per pulse for each encoder (this overrides anything Robotbuilder
        // generates in RobotMap.java)
        
        //leftDriveEncoder.setDistancePerPulse(LEFT_ENCODER_IN_PER_PULSE);
        //rightDriveEncoder.setDistancePerPulse(RIGHT_ENCODER_IN_PER_PULSE);
        getGyroPrefs();
    }

    @Override
    public void periodic() {
        calcDrivetrainSpeeds();
        update_Smartdashboard();
        if 	((m_Zone == 0) && (mLogCoastFlag) && ((rightStats.currVel != 0) || (leftStats.currVel != 0))) {
        	// We have motion (Coasting) so log
        	logDrivetrain();
        }
    }

    // ---------------------------------------------------------------------
    // ----------------- Drive Motor Methods -------------------------------
    // ------------------------------------------------------------------
    public void stopMtrs() {
        motorMode = 0;
        motorLeftPwr = 0;
        motorRightPwr = 0;
        robotDrive.tankDrive(motorLeftPwr, motorRightPwr);
    }

    public void driveByJoystick(Double pwr, Double turn) {
    	m_Zone = 5;
        motorMode = 1;
        motorPwr = pwr;
        motorAngle = turn;
        motorPwr = limitPwr(motorPwr);
        robotDrive.arcadeDrive(motorPwr, motorAngle);
        mLogCoastFlag = false;
    }
    
    public double limitPwr(double power) {
    	// Forward Speed Limit
        if		((Robot.elevSubSys.getElevPos() > 30 && power >= .55)) power = .55;
        else if	((Robot.elevSubSys.getElevPos() > 20 && power >= .60)) power = .60;
        else if	((Robot.elevSubSys.getElevPos() > 10 && power >= .65)) power = .65;
        
        // Reverse Speed Limit
        if		((Robot.elevSubSys.getElevPos() > 15 && power < -0.55)) power = -0.55;
        return power;
    }

    public void driveArcade(float pwr, float turn) {
        motorMode = 2;
        motorPwr = pwr;
        motorPwr = limitPwr(motorPwr);
        motorAngle = turn;
        robotDrive.arcadeDrive(motorPwr, motorAngle);
        mLogCoastFlag = true;
    	logDrivetrain();
    }

    // Gyro assist straight Drive
    public void driveStraightToHdg(double pwr, double tgtYaw) {
        motorMode = 3;
        mTgtYaw = tgtYaw;
        motorPwr = pwr;
        motorPwr = limitPwr(motorPwr);
        gyroCorrection = calcArcadeGyroCorrection();
        motorAngle = gyroCorrection;
        robotDrive.arcadeDrive(motorPwr, motorAngle);
        mLogCoastFlag = true;
    	logDrivetrain();
    }

    // Drive using leftStats and rightStats values
    public void tankDrive(double leftPwr, double rightPwr) {
        motorMode = 5;
        motorLeftPwr = leftPwr;
        motorLeftPwr = limitPwr(motorLeftPwr);
        motorRightPwr = rightPwr;
        motorRightPwr = limitPwr(motorRightPwr);
        robotDrive.tankDrive(motorLeftPwr, motorRightPwr);
        mLogCoastFlag = true;
    	logDrivetrain();
    }

 
    // ------------------------------------------------------------------------
    // ------------------- Get Ultrasound Values ------------------------------
    //double getSonarVolt() 		{ return sonar.getAverageVoltage(); }
    //double getSonarDistance()	{ return (43.57739 * sonar.getAverageVoltage() - 2.04462); }

    // ------------------------------------------------------------------------
    // ------------------------ Encoder Methods -------------------------------
    void initEncoders() {
		leftFrontMtr.setSensorPhase(true);    	
    	
		//leftFrontMtr.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, 1, 10); 
		//leftFrontMtr.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 10);
		//rightFrontMtr.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, 1, 10); 
		//rightFrontMtr.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, 0, 10);
		
		/*
		
		// first choose the sensor
		_talon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
		_talon.setSensorPhase(true);
		_talon.setInverted(false);
		
		// Set relevant frame periods to be at least as fast as periodic rate//
		_talon.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, Constants.kTimeoutMs);
		_talon.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, Constants.kTimeoutMs);

		// set the peak and nominal outputs, 12V means full
		_talon.configNominalOutputForward(0, Constants.kTimeoutMs);
		_talon.configNominalOutputReverse(0, Constants.kTimeoutMs);
		_talon.configPeakOutputForward(1, Constants.kTimeoutMs);
		_talon.configPeakOutputReverse(-1, Constants.kTimeoutMs);
		
		// set closed loop gains in slot0 - see documentation
		_talon.selectProfileSlot(Constants.kSlotIdx, Constants.kPIDLoopIdx);
		_talon.config_kF(0, 0.2, Constants.kTimeoutMs);
		_talon.config_kP(0, 0.2, Constants.kTimeoutMs);
		_talon.config_kI(0, 0, Constants.kTimeoutMs);
		_talon.config_kD(0, 0, Constants.kTimeoutMs);
		// set acceleration and vcruise velocity - see documentation 
		_talon.configMotionCruiseVelocity(15000, Constants.kTimeoutMs);
		_talon.configMotionAcceleration(6000, Constants.kTimeoutMs);
		// zero the sensor
		_talon.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
		
		*/

/*
		// analog signal with no wrap-around (0-3.3V) 
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::Analog, 0, 0); // PIDLoop=0,timeoutMs=0 //
		// eFeedbackNotContinuous = 1, subValue/ordinal/timeoutMs = 0//
		talon.ConfigSetParameter(ParamEnum::eFeedbackNotContinuous, 1, 0x00, 0x00, 0x00);
		// analog signal with wrap-arounds tracked (0-3.3V) //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::Analog, 0, 0); /* PIDLoop=0,timeoutMs=0 //
		// eFeedbackNotContinuous = 0, subValue/ordinal/timeoutMs = 0//
		talon.ConfigSetParameter(ParamEnum::eFeedbackNotContinuous, 0, 0x00, 0x00, 0x00);
		// quadrature //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0); // PIDLoop=0,timeoutMs=0 //
		// CTRE Magnetic Encoder relative, same as Quadrature //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Relative, 0, 0); // PIDLoop=0,timeoutMs=0 //
		// CTRE Magnetic Encoder absolute (within one rotation), same as PulseWidthEncodedPosition //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::CTRE_MagEncoder_Absolute, 0, 0); //PIDLoop=0,timeoutMs=0 //
		// PulseWidthEncodedPosition, LIDAR for example //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::PulseWidthEncodedPosition, 0, 0); //PIDLoop=0,timeoutMs=0 //
		// Tachometer (for velocity closed loop) //
		talon.ConfigSelectedFeedbackSensor(FeedbackDevice::Tachometer, 0, 0); // PIDLoop=0, timeoutMs=0 //

		
		//SetSensorPhase() can be used to keep the sensor and motor in phase for proper limit switch 
		//and closed loop features. 
		// flip input until sensor is in phase //
		talon.SetSensorPhase(true);
		
		*/
	
    }

    public void resetEncodersAndStats() {				// Set Encoders to zero
    	rightFrontMtr.getSensorCollection().setQuadraturePosition(0, 10);    	
    	leftFrontMtr.getSensorCollection().setQuadraturePosition(0, 10);
    	
        leftStats.clearStats();
        rightStats.clearStats();
        avgStats.clearStats();
        // initPosition();			// don't clear position data at this point
        lastTime = Robot.sysTimer.get();
        getPIDPrefs();
    }

    int getLeftEncoder() 					{ return leftFrontMtr.getSelectedSensorPosition(0); }
    int getRightEncoder()					{ return rightFrontMtr.getSelectedSensorPosition(0); }

    int getLeftEncoderVel() 				{ return leftFrontMtr.getSelectedSensorVelocity(0); }
    int getRightEncoderVel()				{ return rightFrontMtr.getSelectedSensorVelocity(0); }    
    
    double getLeftEncoderDist()				{ return (getLeftEncoder() * k_EncConvConst); }
    double getRightEncoderDist()			{ return (getRightEncoder() * k_EncConvConst); }
    public double getAverageDist()			{ return (avgStats.currDist); }
    public double getAverageSpeed()			{ return (avgStats.currVel); }

    // ---------------- Driver Statistics Methods ---------------
    // ------------- Speed and Distance Methods -----------------  
    void calcDrivetrainSpeeds() {
        double time;
        double leftEnc, rightEnc, leftEncDist, rightEncDist, avgEncDist;
        double deltaTime, deltaLeftDist, deltaRightDist;

        time = Robot.sysTimer.get();
        deltaTime = time - lastTime;
        lastTime = time;
        if (deltaTime == 0) {
            deltaTime = 0.00000001;			// prevent divide by zero error
        }
        
        // Calculate Gyro rotation rate 
        mCurrYaw = getGyroYaw();
        double deltaAngle = mLastYaw - mCurrYaw;
   		mLastYaw = mCurrYaw;
   		mGyroAngleRate = ( 1 / deltaTime ) * deltaAngle;
   	    mGyroAngleRate2 = 0;

        leftEnc = getLeftEncoder();
        leftEncDist = getLeftEncoderDist();
        deltaLeftDist = leftEncDist - leftStats.lastDist;

        rightEnc = getRightEncoder();
        rightEncDist = getRightEncoderDist();
        deltaRightDist = rightEncDist - rightStats.lastDist;

        // this is totally bogus .. the encoders are not the same cpr
        // avgEnc = (leftEnc + rightEnc) / 2;	
        avgEncDist = (leftEncDist + rightEncDist) / 2;
        mCurrDist = avgEncDist;								// Used by logging

        leftStats.lastEnc = leftStats.currEnc;
        leftStats.currEnc = leftEnc;
        leftStats.lastDist = leftStats.currDist;
        leftStats.currDist = leftEncDist;
        leftStats.lastVel = leftStats.currVel;
        leftStats.currVel = (leftStats.currDist - leftStats.lastDist) / deltaTime;
        // warning: this is bound to be quite noisy
        leftStats.currAccel = (leftStats.currVel - leftStats.lastVel) / deltaTime;

        rightStats.lastEnc = rightStats.currEnc;
        rightStats.currEnc = rightEnc;
        rightStats.lastDist = rightStats.currDist;
        rightStats.currDist = rightEncDist;
        rightStats.lastVel = rightStats.currVel;
        rightStats.currVel = (rightStats.currDist - rightStats.lastDist) / deltaTime;
        // warning: this is bound to be quite noisy
        rightStats.currAccel = (rightStats.currVel - rightStats.lastVel) / deltaTime;

        avgStats.lastDist = avgStats.currDist;
        avgStats.currDist = avgEncDist;
        avgStats.lastVel = avgStats.currVel;
        avgStats.currVel = (rightStats.currVel + leftStats.currVel) / 2;
        avgStats.currAccel = (avgStats.currVel - avgStats.lastVel) / deltaTime;


        //  ---Calculate Robot position on field---

        mPosn = updatePositions(deltaLeftDist ,deltaRightDist );
        mPosn2 = getPosition();
        avgStats.currXpos=mPosn.x;
        avgStats.currYpos=mPosn.y;
        avgStats.currAngle= mPosn2.yaw;
        avgStats.radius = 0;
    }
 
    // ******************************************************************
    //           Pauls Position Calculation Methods
    // ******************************************************************
    
    // Get Position data in Radians and CCW
    public Posn updatePositions(double leftDist, double rightDist) {
        // restrict the data for same direction assumption
        // this gets any violation of that as close as we can to our assumption
        // if their signs are opposite
        if (Math.signum(leftDist) * Math.signum(rightDist) < 0) {
            // determine which wheel is larger magnitude
            if (Math.abs(leftDist) > Math.abs(rightDist)) {
                // left is larger, so left determines direction
                if (Math.signum(leftDist)<0) {
                    // left is backing so don't let right be positive
                    if (rightDist>0) rightDist = 0 ;
                }
                else {
                    // left is forward so don't let right be negative
                    if (rightDist<0) rightDist = 0 ;
                }
            }
            else {
                // right determines direction
                if (Math.signum(rightDist)<0) {
                    // right is backing so don't let left be positive
                    if (leftDist>0) leftDist = 0 ;
                }
                else {
                    // right is forward so don't let left be negative
                    if (leftDist<0) leftDist = 0 ;
                }
            }
        }
        /***
         * adjustments are simpler for strictly forward assumption
         ***
        if (rightDist<0) rightDist=0 ;
        if (leftDist<0) leftDist=0 ;
        ***/

        // sum and difference between the two wheels
        double rightMinusLeft = rightDist - leftDist;
        double rightPlusLeft = rightDist + leftDist;

        // Note that, for forward travel,
        // a left turn will result in a positive angle and a positive radius
        // a right turn will result in a negative angle and a negative radius
        double angle = rightMinusLeft / mWheelBase ;


        if (angle != 0) {
            // movement in local coordinate system of the robot
            double radius = (rightPlusLeft) / (2*angle) ;
            double arcseg = Math.sqrt(2*radius*radius*(1-Math.cos(angle))) ;
            double angleprime = Math.acos(arcseg/2/radius) ;
            double rely = (radius * Math.sin(angle)) ;
            double relx = (arcseg * Math.cos(angleprime)) ;
            
            // convert those to global coordinate system via rotation
            mPosn.yaw += angle ;
            double cos = Math.cos(mPosn.yaw) ;
            double sin = Math.sin(mPosn.yaw) ;
            double x = cos*relx - sin*rely ;
            double y = sin*relx + cos*rely ;
            
            // now accumulate
            mPosn.x += x ;
            mPosn.y += y ;
        }
        else {  
            // went straight: just use either wheel (or could average here)
            mPosn.y += rightDist ;
            mPosn.x += 0 ;
            mPosn.yaw += 0 ;
        }

        return mPosn ;
    }
    
    // Get Position data in degrees and CW
    public Posn getPosition() {
        Posn posn = new Posn(mPosn) ;
        posn.yaw = -posn.yaw*180/Math.PI ;
        return posn ;
    }  
    
    public void initPosition() {
        mLeftDist = 0 ;
        mRightDist = 0 ;
    	mPosn = new Posn();
    	mPosn2 = new Posn();
    }

    // ----------------------- Zone Data, Distance to Go ------------------------------------------
    public void putZoneData(int zone, double tgtDist, double tgtDistRemain, double tgtYaw, double tgtYawRemain) {
        m_Zone = zone;
        mTgtDist = tgtDist;
        mTgtDistRemain = tgtDistRemain;
        mTgtYaw = tgtYaw ;
        mTgtYawRemain = tgtYawRemain ;
    }

    double getZone()			{ return m_Zone; }
    double getTgtDist() 		{ return mTgtDist; }
    double getTgtDistRemain()	{ return mTgtDistRemain; }
    double getTgtYaw() 			{ return mTgtYaw; }
    double getTgtYawRemain()	{ return mTgtYawRemain; }    
    

    // -----------------------------------------------------------------------
    // ----------------------------- Gyro Routines ---------------------------
    void gyroInit() {
        //gyro.SetDeadband( 0.015);						// may need to play with this value
        //gyro.SetSensitivity(0.007);					// used with analog gyro
    }

    public void resetGyro() {
        mAHRS.zeroYaw();
        System.out.println("Gyro has reset");
    }

    public double getGyroHeading() {
        double hdg = mAHRS.getYaw();
        if (hdg < 0) { hdg += 360; }
        return hdg;
    }

    public double getGyroYaw() 	{ return mAHRS.getYaw(); }

    public double getGyroRate() { 
      	// return mAHRS.getRate();			// tis doesnt seem to be working ???
        //mGyroAngleRate2 = mAHRS.getRate() / mAHRS.getLastSensorTimestamp();
    	return mGyroAngleRate;
    }

    // ----------------- Calculate Correction ----------------------------------------
    double calcArcadeGyroCorrection() {
        mCurrYaw = getGyroYaw();
        double yawerr = mTgtYaw - mCurrYaw;
        if (yawerr > 180)  { yawerr -= 360; }
        if (yawerr < -180) { yawerr += 360; }
        double correctionValue = yawerr * GYROCORRCNST;
        // -- Test for exceeding limits --
        if (correctionValue < 0) {
            if (correctionValue < (-GYROCORRLIMIT)) {
                correctionValue = -GYROCORRLIMIT;
            }
        } else if (correctionValue > GYROCORRLIMIT) {
            correctionValue = GYROCORRLIMIT;
        }
        gyroCorrection = correctionValue;							// For Logging purposes
        if (Math.abs(motorPwr) < 0.2) {
        	// correct for over powering at low speeds
        	gyroCorrection = gyroCorrection * 0.5;
        }
        return correctionValue;
    }

    double calcTankGyroCorrection(double pwrOut, double drift) {
        mCurrYaw = getGyroYaw();
        double yawerr = mTgtYaw - mCurrYaw;
        if (yawerr > 180)  { yawerr -= 360; }
        if (yawerr < -180) { yawerr += 360; }
        
        gyroCorrectedLeft = pwrOut * (1 - yawerr * drift);
        gyroCorrectedRight = pwrOut * (1 + yawerr * drift);
        // make sure the larger drive magnitude isn't bigger than 1
        double max = Math.max(Math.abs(gyroCorrectedLeft), Math.abs(gyroCorrectedRight));
        if (max > 1) {
            gyroCorrectedLeft  = gyroCorrectedLeft  / max;
            gyroCorrectedRight = gyroCorrectedRight / max;
        }
        return yawerr;
    }

    // ------------------------------------------------------------------------
    // ------------------------ Roborio Preferences Methods -----------------------
    public void getPIDPrefs() {
        // grab the relevant coefficients from the smart dashboard
        TGT_STRAIGHT = Robot.prefs.getDouble("Drive_10_PID_Fwd_Tgt", TGT_STRAIGHT);
        TGT_STRAIGHT_HDG = Robot.prefs.getDouble("Drive_10_PID_Fwd_Hdg", TGT_STRAIGHT_HDG);
        KP_STRAIGHT = Robot.prefs.getDouble("Drive_11_PID_Fwd_P", KP_STRAIGHT);
        KI_STRAIGHT = Robot.prefs.getDouble("Drive_12_PID_Fwd_I", KI_STRAIGHT);
        KD_STRAIGHT = Robot.prefs.getDouble("Drive_13_PID_Fwd_D", KD_STRAIGHT);
        KF_STRAIGHT = Robot.prefs.getDouble("Drive_14_PID_Fwd_F", KF_STRAIGHT);
        KMAXOUT_STRAIGHT = Robot.prefs.getDouble("Drive_15_PID_Fwd_MaxOut", KMAXOUT_STRAIGHT);
        ABS_TOL_IN = Robot.prefs.getDouble("Drive_16_PID_Fwd_Tol_In", ABS_TOL_IN);
        KDRIFT_STRAIGHT = Robot.prefs.getDouble("Drive_17_PID_fwd_Drift", KDRIFT_STRAIGHT);
        KMOVERT_STRAIGHT = Robot.prefs.getDouble("Drive_18_PID_Fwd_MoveRt",KMOVERT_STRAIGHT);        
        KBBANG_UPPER_STRAIGHT = Robot.prefs.getDouble("Drive_19_PID_Fwd_BB_Lwr",KBBANG_UPPER_STRAIGHT);
        KBBANG_UPPER_STRAIGHT = Robot.prefs.getDouble("Drive_19_PID_Fwd_BB_Upr",KBBANG_UPPER_STRAIGHT);     

        TGT_ROT = Robot.prefs.getDouble("Drive_20_PID_Rot_Tgt", TGT_ROT);
        KP_ROT = Robot.prefs.getDouble("Drive_21_PID_Rot_P", KP_ROT);
        KI_ROT = Robot.prefs.getDouble("Drive_22_PID_Rot_I", KI_ROT);
        
        KD_ROT = Robot.prefs.getDouble("Drive_23_PID_Rot_D", KD_ROT);
        KF_ROT = Robot.prefs.getDouble("Drive_24_PID_Rot_F", KF_ROT);
        ROT_MAX_PWR = Robot.prefs.getDouble("Drive_25_PID_Rot_MaxOut", ROT_MAX_PWR);
        ABS_TOL_DEG = Robot.prefs.getDouble("Drive_26_PID_Tol_Deg", ABS_TOL_DEG);
        ROT_BBANG_LOWER_THRESH = Robot.prefs.getDouble("Drive_30_PID_Rot_BB_Lwr", ROT_BBANG_LOWER_THRESH);
        ROT_BBANG_UPPER_THRESH = Robot.prefs.getDouble("Drive_31_PID_Rot_BB_Upr", ROT_BBANG_UPPER_THRESH);
        ROT_MOVE_RATE = Robot.prefs.getDouble("Drive_32_PID_Rot_MoveRt", ROT_MOVE_RATE);
    }
    
    public void getGyroPrefs() {
        // grab the relevant data from the smart dashboard
        GYROCORRCNST =Robot.prefs.getDouble("Drive_50_GyroCor", GYROCORRCNST);
        GYROCORRLIMIT =Robot.prefs.getDouble("Drive_51_GyroMax", GYROCORRLIMIT);
    }


    // ------------------------------------------------------------------------
    // ------------------------ Smart Dashboard Methods -----------------------
    void update_Smartdashboard() {
        SmartDashboard.putNumber("Enc-Left Cnt", Rmath.mRound(leftStats.currEnc, 2));
        SmartDashboard.putNumber("Enc-Left Dist", Rmath.mRound(leftStats.currDist, 2));
        SmartDashboard.putNumber("Enc-Right Cnt", Rmath.mRound(rightStats.currEnc, 2));
        SmartDashboard.putNumber("Enc-Right Dist", Rmath.mRound(rightStats.currDist, 2));
        SmartDashboard.putNumber("Drivetrain Average Distance", Rmath.mRound(avgStats.currDist, 2));
        SmartDashboard.putNumber("Drivetrain Average Speed", Rmath.mRound(avgStats.currVel, 2));
        SmartDashboard.putNumber("Rbt X Pos", Rmath.mRound(avgStats.currXpos, 2));
        SmartDashboard.putNumber("Rbt Y Pos", Rmath.mRound(avgStats.currYpos, 2));
        SmartDashboard.putNumber("Rbt Angle", Rmath.mRound(avgStats.currAngle, 2));
        SmartDashboard.putNumber("Rbt Radius", Rmath.mRound(avgStats.radius, 2));
        SmartDashboard.putNumber("Gyro-Yaw", Rmath.mRound(getGyroYaw(), 2));
        SmartDashboard.putNumber("Gyro-Hdg", Rmath.mRound(getGyroHeading(), 2));

        SmartDashboard.putNumber("L Enc Cnt", Rmath.mRound(getLeftEncoder(), 3));
        SmartDashboard.putNumber("R Enc Cnt", Rmath.mRound(getRightEncoder(), 3));
        SmartDashboard.putNumber("L Enc Vel", Rmath.mRound(getLeftEncoderVel(), 3));
        SmartDashboard.putNumber("R Enc Vel", Rmath.mRound(getRightEncoderVel(), 3));
        
        
    }

    // Initialize variables at construction
    void initVar() {
        m_Zone = 0;
        mTgtDist = 0;
        mTgtDistRemain = 0;
        mTgtYaw = 0 ;
        mTgtYawRemain = 0 ;
        lastTime = 0;
        m_LogFlag = false;
        mLogCalcFlag = false;
        mLogCoastFlag = false;
        clearPIDdata();
        initPosition() ;
    }
    
    private void clearPIDdata() {
        mPID_I = 0 ;
        mPID_R = 0 ;
        mPID_O = 0 ;
        mPID_S = 0 ;    	
    }

    public void setLoggingOn()	{ m_LogFlag = true; }
    public void setLoggingOff() { m_LogFlag = false; }
    public void setLogCalcOn()	{ mLogCalcFlag = true; }
    public void setLogCalcOff() { mLogCalcFlag = false; }

    public void logPIDStraightPrefs() {
        line = "***** PID Drivetraight Command - PID Values ";
        line += "  KP=" + KP_STRAIGHT;
        line += "  KI=" + KI_STRAIGHT;
        line += "  KD=" + KD_STRAIGHT;
        line += "  KF=" + KF_STRAIGHT;
        line += "  MaxOut=" + KMAXOUT_STRAIGHT;
        line += "  TOL_IN=" + ABS_TOL_IN;
        line += "  DRIFT=" + KDRIFT_STRAIGHT;
        line += "  MOVE RATE=" + KMOVERT_STRAIGHT;
        line += "  *****";
        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }

    public void logPIDRotatePrefs() {
        line = "***** PID Drive Rotate Command - PID Values ";
        line += "  TGT_ROT," + TGT_ROT;
        line += "  KP," + KP_ROT;
        line += "  KI," + KI_ROT;
        line += "  KD," + KD_ROT;
        line += "  KF," + KF_ROT;
        line += "  MaxOut," + ROT_MAX_PWR;
        line += "  Rot.MoveRt," + ROT_MOVE_RATE;                
        line += "  TOL_IN," + ABS_TOL_DEG;
        line += "  BB_LWR_THRESH=" + ROT_BBANG_LOWER_THRESH;
        line += "  BB_UPR_THRESH=" + ROT_BBANG_UPPER_THRESH;
        line += "  *****";        
        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }
    
    
    // ----------- Log Drivetrain data --------------------
    public void logDrivetrain() {

    	// ----------- Check to see if we should just exit and not log ----------------
        if (m_LogFlag == false) { return; }						// Do not log travel data
        if ((rightStats.currVel == 0) && (leftStats.currVel == 0)) { return; }	// No motion so don't log
        if ((motorMode == 1) && (m_LogFlag == false)) { return; }			// Driving by joystick so don't log
        // ---------- Build Print String -----------------
        line = "";
        // ---------- Show Zone Description ------------
        if ((m_Zone >=  0) && (m_Zone <= 7)) {
        	line += zoneDesc[(int) m_Zone] ;
        } else {
        	line += zoneDesc[8] ;		// Other
        }

        // ------------ Show Current/Remain Dist and Yaw ------------
        line += ", Dist C/R=," + Rmath.mRound(avgStats.currDist,2) + "," + Rmath.mRound(getTgtDistRemain(),2) ;
        line += ", Yaw C/R=," +  Rmath.mRound(mCurrYaw,2) + "," + Rmath.mRound(getTgtYawRemain(),2) ;
        line += " ,Gyro Rt=," +  Rmath.mRound(getGyroRate(),2);        
        // ------------ Show PID Data ------------
        if (( m_Zone == 3) || ( m_Zone== 4)) {
        	line += ",PID I=," + mPID_I + ",PID R=," + mPID_R + ",PID O=," + mPID_O + ",PID S=," + mPID_S ;
        } else {
        	line += ",,,,,,,,";
        }
        
        // ------------ Show current motor pwr ------------
        if ((m_Zone == 0) || (m_Zone == 1) || (m_Zone == 4) || (m_Zone == 7))  {
        	line += ",Pwr L/R=," + motorLeftPwr  + "," + motorRightPwr ; 
    	} else {
        	line += ",Pwr/Dir=," + motorPwr + "," + motorAngle ; 
    	}
        // ---------- Show Speed and Acceleration data for robot ----------
        line += " ,Speed ALR=," + Rmath.mRound(avgStats.currVel,2) + ","
        						+ Rmath.mRound(leftStats.currVel,2) + ","
        						+ Rmath.mRound(rightStats.currVel,2);
        line += " ,Accel=," + Rmath.mRound(avgStats.currAccel,2) ;
        
        // ---------- Show Distance Left/Right for robot ----------
        line += " ,Dist LR=," + Rmath.mRound(leftStats.currDist,3) + ","
        						+ Rmath.mRound(rightStats.currDist,3);    

        // ---------- Show Robot Position data as calculated from left/right encoder distances
        line += " ,Pos XYAR=," + Rmath.mRound(avgStats.currXpos,2) + ","
        						+ Rmath.mRound(avgStats.currYpos,2) +  ","
        						+ Rmath.mRound(avgStats.currAngle,2) + ","
        						+ Rmath.mRound(avgStats.radius,2);

        // ---- send line to Logger ---------
        Robot.logger.appendLog(line);
    }
    

    // ********************************************************************************
    //                      PID METHODS AND CLASS 
    // ********************************************************************************
    // Drive straight using a PID for a given distance
    public void driveStraightPid(double distance, double tgtYaw) {
    	stopPID();												// In case previous Pid still in operation
    	motorMode = 6;
        mDriveMode = DriveMode.AUTO_STRAIGHT;					// record that we're in PID mod
        PIDTgtYaw = tgtYaw ;
        getPIDPrefs();											// Get PID Constant data
        getGyroPrefs();											// Get Update Gyro COnstants
        if (distance == 999) {
            PIDTgtDist = TGT_STRAIGHT;
            PIDTgtYaw = TGT_STRAIGHT_HDG;
        } else {
        	PIDTgtDist = distance;
        } 
      	line = "***** Entering PID driveStraight    Distance =" + PIDTgtDist + "  PIDTgtYaw=" + PIDTgtYaw +" ******";
        System.out.println(line);
        Robot.logger.appendLog(line);
        logPIDStraightPrefs();
        mSuperPid = new DistancePid(PIDTgtDist, KP_STRAIGHT, 0, KD_STRAIGHT, KF_STRAIGHT);
        resetEncodersAndStats();										// reset the encoder counts
        mDrivePIDStatus = DrivePIDStatus.RUNNING;
        mSuperPid.start();										// start the PID IO (and the PID)
    } 
    
    // Drive Point turn using a PID for a given angle of rotation
    public void pidRotateTo(double angleDeg) {
    	stopPID();												// In case previous Pid still in operation
        motorMode = 7;
        mDriveMode = DriveMode.AUTO_ROTATE;
        getPIDPrefs();											// Get PID Constant data
        if (angleDeg == 999) {
            PIDTgtYaw = TGT_ROT;	        	
        } else {
        	PIDTgtYaw = angleDeg;
        }
        PIDTgtDist = 0;				// point turn has no distance
      	line = "***** Entering PID Rotate - PIDTgtYaw=" + PIDTgtYaw +" ******";
        System.out.println(line);
        Robot.logger.appendLog(line);
        logPIDRotatePrefs();
        System.out.println("PID D=" + KD_ROT);
        mSuperPid = new RotationPid(PIDTgtYaw, KP_ROT, 0, KD_ROT, KF_ROT);	// create PID controller
        //m_TgtAngleRemain = degrees;
        mDrivePIDStatus = DrivePIDStatus.RUNNING;
        mSuperPid.start();
    }

    // a Command can call this to force a stop (e.g., from a watchdog timer)    
    public void stopPID() {
        // stop the drive motors and shutdown automation
    	line = "****** STOPPING PID AUTOMATION (stopPID() was Called) *****";
        //System.out.println(line);
        Robot.logger.appendLog(line);
        if (mSuperPid != null) {
        	mSuperPid.stop();			
        }
        mDriveMode = DriveMode.TELE;
        mDrivePIDStatus = DrivePIDStatus.STOPPED;
        stopMtrs();						// The pid never sends a stop .. so motor continues running
        Robot.drivetrain.putZoneData(0, 0.0, 0.0, 0.0, 0.0);					// Stop logging distance to tgt
    }

    // 	***********  PID Routines  ******************    
    // a Command can call this to see what mode were in
    public DriveMode getDriveMode() { 
    	return mDriveMode;
    	}
    
    // a Command can call this to see if we're done
    public DrivePIDStatus getDrivePIDStatus() { 
    	return mDrivePIDStatus;
    	}    

    
    // --------------------------------------------------------------------------------
    //                       Inner DISTANCE PID CLASS
    // --------------------------------------------------------------------------------

    private class DistancePid extends SuperPid { 
        int mLogCounter = 0; 
        // constructor
        public DistancePid(double distance, double Kp, double Ki, double Kd, double Kf) {
            super(distance, Kp, Ki, Kd, Kf);
            mOptions.setKeepRunningCriteria(true, distance * .01 );
            mOptions.setRamping(true, KMOVERT_STRAIGHT);							// use ramping
            //mOptions.setOutputRange(KMAXOUT_STRAIGHT, -KMAXOUT_STRAIGHT); 	// Limit output (speed)
            if (distance > 96) {
            	mOptions.setOutputRange(0.8, -0.8); 	// Limit output (speed)
            } else if ( distance >= 20) {
            	mOptions.setOutputRange(0.75, -0.75); 	// Limit output (speed)
            } else {
            	mOptions.setOutputRange(0.7, -0.7); 	// Limit output (speed)
            }
            
            //mOptions.setBangBang(true, KBBANG_UPPER_STRAIGHT, KBBANG_LOWER_STRAIGHT);
            mOptions.setBangBang(false, 0, 0);
        }

        @Override
        public void applyPidOutput(double output) {
        	motorPwr = limitPwr(output);
        	motorAngle = calcArcadeGyroCorrection();
            // if (mLogCounter == 0) {  System.out.println("*** gyroCorrection=" + motorAngle;  }
            // mLogCounter = (mLogCounter + 1) % 5;
        	PIDTgtYawRemain = PIDTgtYaw - getGyroYaw();
            robotDrive.arcadeDrive(motorPwr, motorAngle);
            putZoneData(3, PIDTgtDist, PIDTgtDistRemain, PIDTgtYaw, PIDTgtYawRemain);	// PIDremain calc in getPidInput
            mLogCoastFlag = true;
            logDrivetrain();
            
        }

        @Override
        public double getPidInput() {
            PIDTgtDistRemain = PIDTgtDist - getAverageDist();					 // these are in inches
            // consider testing for termination condition here such as velocity is almost zero 
            // such as maybe we hit something. or we just don't have enough correction pwr to continue
            return getAverageDist();
        }

        @Override
        public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut,  double setpoint ) {
            //Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
            if (status == PidStatus.RUNNING) {
                mDrivePIDStatus = DrivePIDStatus.RUNNING;
                mPID_I = input ;
                mPID_R = rawOutput ;
                mPID_O = pidOut ;
                mPID_S = setpoint ;
                return;
            } else if (status == PidStatus.STOPPED) {
            	Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
                mDriveMode = DriveMode.DONE;
                mDrivePIDStatus = DrivePIDStatus.STOPPED;
                clearPIDdata();
                stopMtrs();						// The pid never sends a stop .. so motor continues running
                return;
            } else if (status == PidStatus.ATEND) {
            	Robot.logger.appendLog(" AN update of Fwd PIDStatus has been received PidStatus=" + status );
                mDrivePIDStatus = DrivePIDStatus.ATEND;
                mDriveMode = DriveMode.DONE;            	
            	// consider testing for termination condition here such as
                return;
            }
        }
    }

    // ********************************************************************************
    //                      PID ROTATION METHODS AND CLASS 
    // ********************************************************************************
 
    // --------------------------------------------------------------------------------
    //                       Inner Rotation PID CLASS
    // --------------------------------------------------------------------------------
    private class RotationPid extends SuperPid {
        private double mTargetDeg;
        public RotationPid(double degrees, double Kp, double Ki, double Kd, double Kf) {
            super(validateDeg(degrees), Kp, Ki, Kd, Kf);
            mOptions.setKeepRunningCriteria(false, 1);
            mOptions.setBangBang(true, ROT_BBANG_UPPER_THRESH, ROT_BBANG_LOWER_THRESH);
            mOptions.setInputWrap(true, -180, +180);
            mOptions.setRamping(false, 4);
            mOptions.setOutputRange(ROT_MAX_PWR, -ROT_MAX_PWR); 	// Limit output (speed)
        }

        @Override
        public void applyPidOutput(double output) {
            motorLeftPwr = output;
            motorRightPwr = -output;
            robotDrive.tankDrive(motorLeftPwr, motorRightPwr);
            putZoneData(4, 0 , 0, mTgtYaw, PIDTgtYawRemain);
            mLogCoastFlag = true;
            logDrivetrain();
        }

        @Override
        public double getPidInput() {
        	mCurrYaw = getGyroYaw();			// Update for logging
        	PIDTgtYawRemain = PIDTgtYaw - mCurrYaw;
            return mCurrYaw;
        }

        @Override
        public void updatePidStatus(SuperPid.PidStatus status, double input, double rawOutput, double pidOut, double setpoint ) {
            if (status == PidStatus.RUNNING) {
            	mDrivePIDStatus = DrivePIDStatus.RUNNING ;
                mPID_I = input ;
                mPID_R = rawOutput ;
                mPID_O = pidOut ;
                mPID_S = setpoint ;
            } else if (status == PidStatus.STOPPED) {
                Robot.logger.appendLog(" AN update of ROT PIDStatus has been received PidStatus=" + status );
                // The PID is done (Stopped) because of end of travel (we reached Setpoint)
                mDrivePIDStatus = DrivePIDStatus.STOPPED;
                mDriveMode = DriveMode.DONE;
                clearPIDdata();
                stopMtrs();						// The pid never sends a stop .. so motor continues running
            } else if (status == PidStatus.ATEND) {
            	// The PID is at the end but no stopping has been set
                // consider testing for termination condition here such as
                // 1. Timer - when distance is within tolerance start timer and after 0.25 seconds end run
                // 2. Look at velocity and when in tolerance zone if velocity is less than ~5 inches per sec. end run
                // stop based on rate
                Robot.logger.appendLog(" AN update of ROT PIDStatus has been received PidStatus=" + status );
            	mDrivePIDStatus = DrivePIDStatus.ATEND ;
            }  
        }
    }

    // ------- Limit degrees -------
    private double validateDeg(double deg) {
        if (deg > 180) {
            deg = 180;
        }
        if (deg < -180) {
            deg = -180;
        }
        return deg;
    }

    // *****************************************************************************
    // Inner CLASS to store data for leftStats, rightStats, average motor statistics
    // *****************************************************************************
    private class DriveStats {

        double currEnc, lastEnc;
        double currDist, lastDist;
        double currVel, lastVel;
        double currPwr, currAccel;
        double currXpos, lastXpos, currYpos, lastYpos;
        double currAngle, lastAngle, radius;

        public DriveStats() {
            clearStats();
        }

        public void clearStats() {
            currEnc = 0;
            lastEnc = 0;
            currDist = 0;
            lastDist = 0;
            currVel = 0;
            lastVel = 0;
            currPwr = 0;
            currAccel = 0;
            currXpos = 0;
            lastXpos = 0;
            currYpos = 0;
            lastYpos = 0;
            currAngle = 0;
            lastAngle = 0;
            radius = 0;
        }
    }
    
    // ******************************************************************
    //           Pauls Position CLASS
    // ******************************************************************
    
    private class Posn {
        double x, y, yaw ;
        public Posn() {
            x = 0 ; y = 0 ; yaw = 0 ;
        }
        public Posn(Posn p) {
            x = p.x ; y=p.y ; yaw = p.yaw ;
        }
    } 
}
